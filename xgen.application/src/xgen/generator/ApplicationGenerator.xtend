/*
 * generated by Xtext
 */
package xgen.generator

import java.util.Objects
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import xgen.application.Application
import xgen.generate.Iteration
import xgen.grammar.util.GrammarConverter
import xgen.grammar.util.GrammarUtil
import xgen.output.ApplicationOutput
import xgen.parsetree.Setting
import xgen.postprocess.PostProcessors

import static xgen.grammar.util.GrammarConstructor.*
import xgen.generator.pp.FSMLPP

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ApplicationGenerator implements IGenerator {

	def getEffectiveGrammar(Application it) {
		val g = GrammarConverter.fromXText(target)

		for (rr : ruleReplacements)
			GrammarUtil.getDefinition(g, rr.target.name).ifPresent[rhs = rr.replacement]

		// Sort by position descending so we don't mess up positions replacing prior candidates
		val crs = constructReplacements.sortBy[if(positioned) -position else 1]
		val mas = multiplicityAdjustments.sortBy[if(positioned) -position else 1]

		for (cs : crs)
			GrammarUtil.getDefinition(g, cs.target.name).ifPresent [
				rhs = GrammarUtil.selectTransform(rhs, [x|EcoreUtil.equals(cs.selector, x)],
					[x|EcoreUtil.copy(cs.replacement)], cs.positioned, cs.position);
			]

		for (ma : mas)
			GrammarUtil.getDefinition(g, ma.target.name).ifPresent [
				rhs = GrammarUtil.adjustMultiplicity(rhs, [x|multiplicity(x.operand, ma.min, ma.upperBounded, ma.max)],
					ma.positioned, ma.position)
			]

		return g
	}

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		for (a : resource.allContents.filter(Application).toIterable) {

			// Get effective grammar from application
			val g = a.effectiveGrammar

			// Make iteration from grammar
			val i = new Iteration(g)

			// Iterate the first rule
			val x = i.iterate(g.definitions.findFirst[!lexical])

			// Post-process
			val y = FSMLPP.fsmlPP.postProcess(PostProcessors.annotate(null, x))

			ApplicationOutput.print("Iteration", null,
				[ o |
					o.println()
					// Print some items
					for (p : 0 .. 100) {
						y.get(p).ifPresent [ pt |
							o.println("Test-data #" + p.toString);
							o.println(Objects.toString(pt.a))
							o.println("--------------------------------------------");
							o.println(pt.b.flatten(Setting.DEFAULT_SETTING, false));
							o.println();
						]
					}
				])

		}
	}
}
