/*
 * generated by Xtext
 */
package xgen.generator

import com.google.common.collect.ContiguousSet
import com.google.common.collect.DiscreteDomain
import com.google.common.collect.Range
import java.math.BigDecimal
import java.util.Objects
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import xgen.application.Application
import xgen.generate.Iteration
import xgen.generator.pp.FSMLPP
import xgen.grammar.util.GrammarConverter
import xgen.grammar.util.GrammarUtil
import xgen.output.ApplicationOutput
import xgen.parsetree.Setting
import xgen.postprocess.PostProcessors

import static xgen.generator.BSU.*
import static xgen.grammar.util.GrammarConstructor.*

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ApplicationGenerator implements IGenerator {
	val STANDART_LIMIT = 1_000_000

	def getEffectiveGrammar(Application it) {
		val g = GrammarConverter.fromXText(target)

		for (rr : ruleReplacements)
			GrammarUtil.getDefinition(g, rr.target.name).ifPresent[rhs = rr.replacement]

		// Sort by position descending so we don't mess up positions replacing prior candidates
		val crs = constructReplacements.sortBy[if(positioned) -position else 1]
		val mas = multiplicityAdjustments.sortBy[if(positioned) -position else 1]

		for (cs : crs)
			GrammarUtil.getDefinition(g, cs.target.name).ifPresent [
				rhs = GrammarUtil.selectTransform(rhs, [x|EcoreUtil.equals(cs.selector, x)],
					[x|EcoreUtil.copy(cs.replacement)], cs.positioned, cs.position);
			]

		for (ma : mas)
			GrammarUtil.getDefinition(g, ma.target.name).ifPresent [
				rhs = GrammarUtil.adjustMultiplicity(rhs, [x|multiplicity(x.operand, ma.min, ma.upperBounded, ma.max)],
					ma.positioned, ma.position)
			]

		return g
	}

	static class TL {
		val long start
		var long end

		new() {
			start = System.nanoTime
		}

		def getStart() {
			return start
		}

		def getEnd() {
			return end
		}

		def stop() {
			end = System.nanoTime
		}

		def duration() {
			return (end - start) * 1e-9
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		for (a : resource.allContents.filter(Application).toIterable) {

			ApplicationOutput.print("Iteration", null,
				[ o |
					o.println("Beginning iteration")
					// Get effective grammar from application
					val g = a.effectiveGrammar
					// Start time calculation
					val calculation = new ApplicationGenerator.TL
					// Make iteration from grammar
					val i = new Iteration(g)
					// Iterate the first rule
					val x = i.iterate(g.definitions.findFirst[!lexical])
					// Post-process
					val y = FSMLPP.fsmlPP.postProcess(PostProcessors.annotate(null, x))
					// Stop time calculation
					calculation.stop
					// Initialize metric store
					val count = newArrayList(0BD)
					val size = newArrayList(0BD)
					// Start time construction
					val construction = new ApplicationGenerator.TL
					// Print items
					for (p : ContiguousSet.create(Range.closedOpen(0L, y.bound.orElse(STANDART_LIMIT)),
						DiscreteDomain.longs)) {
						y.get(p).ifPresent [ pt |
							// Get flattened
							val d = pt.b.flatten(Setting.DEFAULT_SETTING, false)
							// Increment the metrics
							count.set(0, count.head + 1BD)
							size.set(0, size.head + BigDecimal.valueOf(d.bytes.length))
							// Optionally print
							if (a.examples.contains(p as long as int)) {
								o.println("Test-data #" + p.toString);
								o.println(Objects.toString(pt.a))
								o.println("--------------------------------------------");
								o.println(d);
								o.println();
							}
						]
					}
					// Stop time construction
					construction.stop
					// Print metrics
					o.println("Calculated (s): " + calculation.duration)
					o.println("Constructed (s): " + construction.duration)
					o.println("Created: " + count.head)
					o.println("Size: " + prettySize(size.head))
				])

		}
	}
}
