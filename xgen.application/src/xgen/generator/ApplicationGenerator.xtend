/*
 * generated by Xtext
 */
package xgen.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import xgen.generate.Iteration
import xgen.postprocess.Processor
import java.util.Collection
import java.util.List
import java.util.Random
import xgen.parsetree.Leaf
import xgen.postprocess.TransformSome
import xgen.postprocess.RemoveAll
import xgen.postprocess.TransformAll
import xgen.application.Application
import xgen.grammar.util.GrammarConverter
import xgen.grammar.util.GrammarUtil
import xgen.postprocess.TransformOne
import xgen.grammar.Reference
import org.eclipse.emf.ecore.util.EcoreUtil

class ReplaceInitial extends TransformOne {

	override protected select(Leaf it) {
		value == "<initial>"
	}

	override protected transform(Leaf it) {
		new Leaf("initial")
	}

}

class RemoveRemainingInitial extends RemoveAll {

	override protected remove(Leaf it) {
		value == "<initial>"
	}
}

class ReplaceInputValue extends TransformAll {
	var i = 0
	var j = #["SomeInput", "MoreInput", "SlightlyDifferentInput", "EvenMore"]

	override protected transform(Leaf it) {
		if (value != "<input value>")
			return it

		val r = j.get(i % j.size)

		i = i + 1

		return new Leaf(r)
	}
}

class ReplaceStateName extends TransformAll {
	var i = 0
	val Collection<String> exchange

	new(Collection<String> exchange) {
		this.exchange = exchange
	}

	override protected resetOne() {
		i = 0
		exchange.clear
	}

	override protected transform(Leaf it) {
		if (value != "<state name>")
			return it

		val r = "State" + i

		i = i + 1

		exchange += r
		return new Leaf(r)
	}
}

class ReplaceStateRef extends TransformAll {
	val random = new Random
	val List<String> exchange

	new(List<String> exchange) {
		this.exchange = exchange
	}

	override protected transform(Leaf it) {
		if (value != "<state ref>")
			return it

		new Leaf(exchange.get(random.nextInt(exchange.size)))
	}
}

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ApplicationGenerator implements IGenerator {

	def getEffectiveGrammar(Application it) {
		val g = GrammarConverter.fromXText(target)

		for (r : ruleReplacements)
			for (d : g.definitions)
				if (d.name == r.target.name)
					d.rhs = r.replacement

//		for (c : callReplacements)
//			GrammarUtil.transformIn(g, [it instanceof Reference && (it as Reference).target == c.selector.name],
//				[EcoreUtil.copy(c.replacement)])

		return g
	}

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		// Exchange buffer object for the generated states in the replace state name PP
		val s = newArrayList()

		// Processor sequence
		val t = Processor.compose(new ReplaceInitial, new RemoveRemainingInitial, new ReplaceInputValue,
			new ReplaceStateName(s), new ReplaceStateRef(s))

		for (a : resource.allContents.filter(Application).toIterable) {

			// Get effective grammar from application
			val g = a.effectiveGrammar

			// Make iteration from grammar
			val i = new Iteration(g)

			// Iterate the first rule
			val x = i.iterate(g.definitions.findFirst[!lexical])

			// Post-process
			val y = t.postProcess(x)

			// Print some items
			for (p : a.min .. a.max) {
				y.get(p).ifPresent[println(p); print("  "); println(flatten(false))]
			}
		}
	}
}
